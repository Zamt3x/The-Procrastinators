#!/usr/bin/env python
from fuzzywuzzy import process, fuzz
import random, json, aiml, sys, os

# Void any output to stdout until the actual result that comes later
sys.stdout = open(os.devnull, "w")

# If the application is run as a bundle, PyInstaller bootloader extends the sys
# module with flag frozen and puts the app path into variable _MEIPASS
# (getting the appropriate resource paths under development and production env)
if getattr(sys, "frozen", False):
    current_dir = sys._MEIPASS
else:
    current_dir = os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), "data")


class ErrorFilter(object):
    def __init__(self, stream):
        self.stream = stream

    def __getattr__(self, attr_name):
        return getattr(self.stream, attr_name)

    def write(self, data):
        if "maximum recursion depth exceeded" not in data:
                self.stream.write(data)
                self.stream.flush()
        else:
            sys.stdout.write("Wow, that really took my head for a spin! Please don't say that again.")
            sys.stdout.flush()

    def flush(self):
        self.stream.flush()


def get_bot_predicates():
    with open(os.path.join(current_dir, "predicates.json"), "r", encoding="utf-8") as f:
        return json.loads(f.read())


def get_medical_data():
    with open(os.path.join(current_dir, "symptoms.json"), "r", encoding="utf-8") as f:
        illness_per_symptom = json.loads(f.read())
        symptoms = list(illness_per_symptom.keys())
        return (illness_per_symptom, symptoms)


def get_medical_response(illnesses, symptom_data):
    rand_illness = random.choice(illnesses[symptom_data[0]])
    responses = [
        f"Oh no... It looks like you may have a case of {rand_illness}, and I'm {symptom_data[1]}% sure that you'll die.",
        f"{rand_illness.capitalize()} is quite serious, you should definitely go see a real doctor.",
        f"{rand_illness.capitalize()} is not that serious, stop feeling sorry for yourself.",
        f"Stop bothering me with trivial things like {rand_illness}, I don't have time for that.",
        f"There is hope that you don't have {rand_illness}, about {100 - symptom_data[1]}% chance."
    ]
    return random.choice(responses)


kernel = aiml.Kernel()
kernel.bootstrap(brainFile = os.path.join(current_dir, "brain.brn"))

for predicateName, predicate in get_bot_predicates().items():
        kernel.setBotPredicate(predicateName, predicate)

illnesses, symptoms = get_medical_data()

# Reinstate the normal stdout to pipe the result to it
#
# Python stdout also uses the default encoding of the terminal or console that
# calls the script, meaning utf-8 has to be set explicitly for it to be reliable
sys.stdout = open(sys.__stdout__.fileno(), mode="w", encoding="utf-8", buffering=1)
# Replace stderr with a filter class to catch a recursion warning generated by the
# aiml library, raise a RecursionError from it, and finally handle the exception
# appropriately to not get stuck in an infinite loop (generated by some user input)
sys.stderr = ErrorFilter(sys.stderr)

while True:
    # Suppressing EOF error avoids unwanted dialog popping up on program exit
    try:
        usr_inp = input()
    except EOFError:
        sys.exit(0)

    # Generating the two initial responses
    response = kernel.respond(usr_inp)
    medical_match = process.extract(usr_inp, symptoms, scorer=fuzz.token_set_ratio)[0]

    # Override the original response with a medical one if the criteria is met
    if medical_match[1] >= 75:
        response = get_medical_response(illnesses, medical_match)

    sys.stdout.write(response)
    sys.stdout.flush()
